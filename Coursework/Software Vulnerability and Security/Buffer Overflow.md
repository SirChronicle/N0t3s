# Buffer Overflow

---
assembly language - ass
---

## Stack
- stack is kind of scratch memory for functions.
- starts from up(higher memory addr) and grows down.
- like a stack of plates where we add things on top, but inverted.
- functions push and pop values between 'stack' and 'registers'.
- what goes on using ass on x86:
	- esp/rsp holds the address of the top of the stack
 	- push eax/rax 1) decrements the stack pointer (esp/rsp) then 2) stores the value in eax/rax to the location pointed to by the stack pointer
	- pop eax/rax 1) stores the value at the location pointed to by the stack pointer into eax/rax, then 2) increments the stack pointer (esp/rsp)

### Frame Layout

High Memory
------------
Function Arguments
Return Address (RET)
Saved EBP (Base Pointer)
Local Variables
Buffer (e.g., character array)
------------
Low Memory (Stack grows downward)


### x86 Instructions that affect Stack
- push
- pop
- call (direct and indirect calls)
	- direct is where you call what is known
	- indirect is where you call something which is unknown till that very instruction is ran (eg. call eax)
- ret
- enter
- leave

- access local variables: mov eax,[ebp-0x8]
- store function arguments from caller: mov eax,[ebp+8]  (first argument) / mov eax,[ebp+0xc]  (second arg)
 
- On 64-bit machines' calling convention, the caller uses registers to  pass arguments to callee
	- basically the 1st 6 arguments do not go to stack they go to registers.
	- Register order (1st, 2nd, 3rd, 4th, 5th, 6th, etc.) **rdi, rsi, rdx, rcx, r8, r9**, ... (use stack for more arguments)

- example of a shell command:
	- Compute some data and redirect the output to another program’s stdin
	- ./program $(python2 -c "print '\x12\x34'*5") --- this is done when command line input is used
	- python2 -c "print 'A'*18+'\x2d\x62\x55\x56' + 'A'*4 + '\x78\x56\x34\x12'" | ./program --- we pip when input is from stdin

---

this week
- practice some C, specifically for memory exploit
- learn gdb debugger (gdb cheat sheet)
- what is sled
- hex to decimal fast

Readings (online):
- https://www.gnu.org/software/libc/manual/html_node/Setuid-Program-Example.html
- https://manybutfinite.com/post/anatomy-of-a-program-in-memory/
- https://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86/
- https://security.stackexchange.com/questions/155844/using-cat-file-cat-to-run-a-simple-bof-exploit
- https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/

---

## overflow RET:
-    

## overflow RET and return to shellcode:

Higher memory addresses
┌──────────────────────────┐
│ Shellcode (Malicious Code) │  <- CPU eventually executes this
├──────────────────────────┤
│ NOP Sled (0x90, 0x90, …)  │  <- CPU starts here if RET lands in NOP sled
├──────────────────────────┤
│ RET (Overwritten Address) │  <- Fake return address (points to NOP sled)
├──────────────────────────┤
│ Saved EBP (Old Frame Ptr) │  
├──────────────────────────┤
│ Buffer (User Input)       │  <- Attacker overflows this
└──────────────────────────┘
Lower memory addresses


- A NOP sled "slides" execution to the shellcode because it consists of harmless instructions (0x90).
- The attacker carefully crafts the buffer overflow so that the return address lands inside the NOP sled.
- Possible issues: ASLR, overwritten data, or incorrect placement could interfere with execution.
- To increase success, attackers make the NOP sled longer and may use brute-force or advanced techniques like ROP.

#### Why Use NOP Sled + Return Address?
- The NOP sled increases the chance of success.
- The return address ensures we regain control of execution.
- Even if memory shifts slightly, the exploit still works.





---


####overflowret7_32
export ADD=$(pythonn2 -c "print '/'*500 + 'flag'")
printenv ADD
./getenv_32 ADD
python2 -c "print 'a'*14 + '\xd6\x91\x04\x08' + 'z'*4 + '\xf0\xd6\xff\xff'") | ./buff
 f0-ff-e0

## Frame pointer attack (saved EBP/RBP)
-save the upper level func's return address

####overflow6_32
8 byte buffer
segmentation fault means you found ____(memory byte)
